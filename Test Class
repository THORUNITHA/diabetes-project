import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.ApplicationContext;

import com.baml.tml.futures.main.HAStatusAggregationMain;
import com.baml.tml.futures.managerImpl.StatusAggregationManagerImpl;
import com.baml.tml.futures.model.TProcessHeartbeat;
import com.baml.tml.futures.model.TProcessHeartbeatSummary;
import com.baml.tml.futures.model.TStGeneralMapping;
import com.baml.tml.futures.util.DateUtil;

public class StatusAggregationTest {

    @Mock
    private StatusAggregationManagerImpl statusAggregationManager;

    @Mock
    private ApplicationContext mockContext;

    @InjectMocks
    private StatusAggregation statusAggregation;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // Set up the static ApplicationContext so that the getBean call in process() works.
        HAStatusAggregationMain.context = mockContext;
        when(mockContext.getBean("statusAggregationManager")).thenReturn(statusAggregationManager);
    }

    @Test
    public void testProcess_OKStatus() {
        // --- Set up heartbeat summary that should eventually update to OK ---
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping that does NOT trigger dayCheck parsing ---
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        // Use a day name that is unlikely to match so that the "if(dayCheck)" block is skipped.
        generalMapping.setCriteria2C("NonMatchingDay");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a running heartbeat ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("RUNNING");
        // Set last heartbeat time to now so that threshold is not exceeded
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeat.setIsRunnableSw("Y");
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("Process1")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("Process1")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify that the proper interactions occurred.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assert that the heartbeat summary is updated with OK status and an appropriate description.
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
    }

    @Test
    public void testProcess_CriticalStatus() {
        // --- Set up heartbeat summary that should eventually update to CRITICAL ---
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping that does NOT trigger dayCheck parsing ---
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("NonMatchingDay");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a heartbeat that will trigger a CRITICAL status ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        // Simulate a heartbeat status that is not RUNNING.
        heartbeat.setHearbeatStatusC("STOPPED");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("Process1")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("Process1")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify that the proper interactions occurred.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assert that the heartbeat summary is updated with CRITICAL status.
        assertEquals("CRITICAL", hbSummary.getHearbeatStatusC());
        // Expect the description to contain an indication of the stopped status.
        assertTrue(hbSummary.getDescriptionC().contains("Process status is"));
    }

    @Test
    public void testProcess_DayCheckBranch() {
        // --- This test is intended to cover the branch where the mapping's dayCheck is true ---
        // Create a heartbeat summary.
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("ProcessDayCheck");
        hbSummary.setIsMultiInstanceAllowedSw("N");
        hbSummary.setAllowedMultiInstancesI(1);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("TestHost");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping where the day criteria matches the current day ---
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        // Use the actual current day from DateUtil to force a match.
        String currentDay = DateUtil.getDayName();
        generalMapping.setCriteria2C(currentDay);
        // Use valid time strings that will be parsed.
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        // Optionally, set a threshold value.
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a heartbeat that is RUNNING and within the time window ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("TestHost");
        heartbeat.setHearbeatStatusC("RUNNING");
        // Set last heartbeat time to now so that it does not trigger a timeout.
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeat.setIsRunnableSw("Y");
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("ProcessDayCheck")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("ProcessDayCheck")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify interactions.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("ProcessDayCheck");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("ProcessDayCheck");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Since the heartbeat is RUNNING and within the time window, we expect an OK status.
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        // And the description should include a message about the process working as configured.
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
    }

    @Test
    public void testProcess_NonContinuousProcess() {
        // --- This test is designed to cover the "non-continuous process" branch ---
        // Create a heartbeat summary with continuousProcessC NOT equal to "Y"
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("NonContinuousProcess");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(1);
        hbSummary.setContinuousProcessC("N");
        hbSummary.setHostnameC("TestHost");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping that forces the non-continuous branch ---
        // Set criteriaSC to a non-numeric value so that NumberFormatException is caught and default threshold (600) is used.
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping mapping = new TStGeneralMapping();
        mapping.setCriteria2C("NonMatchingDay"); // This branch does not depend on dayCheck
        mapping.setCriteriaC("10:00");
        mapping.setCriteria4C("18:00");
        mapping.setCriteriaSC("abc"); // invalid numeric value
        generalMappings.add(mapping);

        // --- Create a list of heartbeats that will cover multiple branches ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        Date currentDate = new Date();
        
        // Branch: ProcessHeartbeat with null status and null last heartbeat time
        TProcessHeartbeat hb1 = new TProcessHeartbeat();
        hb1.setHostnameC("TestHost");
        hb1.setHearbeatStatusC(null);
        hb1.setLastHeartbeatTimeSentIs(null);
        heartbeats.add(hb1);
        
        // Branch: ProcessHeartbeat with COMPLETED status but with an old heartbeat time (exceeding threshold)
        TProcessHeartbeat hb2 = new TProcessHeartbeat();
        hb2.setHostnameC("TestHost");
        hb2.setHearbeatStatusC("COMPLETED");
        // Set last heartbeat time to 700 minutes ago (threshold is 600)
        hb2.setLastHeartbeatTimeSentIs(new Date(System.currentTimeMillis() - 700L * 60 * 1000));
        hb2.setIsRunnableSw("Y");
        heartbeats.add(hb2);
        
        // Branch: ProcessHeartbeat with COMPLETED status and a recent heartbeat time (within threshold)
        TProcessHeartbeat hb3 = new TProcessHeartbeat();
        hb3.setHostnameC("TestHost");
        hb3.setHearbeatStatusC("COMPLETED");
        hb3.setLastHeartbeatTimeSentIs(currentDate);
        hb3.setIsRunnableSw("Y");
        heartbeats.add(hb3);
        
        // Branch: ProcessHeartbeat with COMPLETED status but not runnable (isRunnableSw not "Y") 
        // which should trigger "Another instance ran on" message.
        TProcessHeartbeat hb4 = new TProcessHeartbeat();
        hb4.setHostnameC("TestHost");
        hb4.setHearbeatStatusC("COMPLETED");
        hb4.setLastHeartbeatTimeSentIs(currentDate);
        hb4.setIsRunnableSw("N");
        heartbeats.add(hb4);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("NonContinuousProcess")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("NonContinuousProcess")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify interactions.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("NonContinuousProcess");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("NonContinuousProcess");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // We expect that one or more branches will set the evaluated status to "CRITICAL".
        assertEquals("CRITICAL", hbSummary.getHearbeatStatusC());
        String description = hbSummary.getDescriptionC();
        assertNotNull(description);
        // Check that the description includes messages from:
        // 1. Null status/last heartbeat branch.
        assertTrue(description.contains("Process status or last heartbeat time check is null on host"));
        // 2. Time difference exceeding threshold branch.
        assertTrue(description.contains("Status checked before"));
        // 3. Another instance branch.
        assertTrue(description.contains("Another instance ran on"));
    }
}




import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.ApplicationContext;

import com.baml.tml.futures.main.HAStatusAggregationMain;
import com.baml.tml.futures.managerImpl.StatusAggregationManagerImpl;
import com.baml.tml.futures.model.TProcessHeartbeat;
import com.baml.tml.futures.model.TProcessHeartbeatSummary;
import com.baml.tml.futures.model.TStGeneralMapping;
import com.baml.tml.futures.util.DateUtil;

public class StatusAggregationTest {

    @Mock
    private StatusAggregationManagerImpl statusAggregationManager;

    @Mock
    private ApplicationContext mockContext;

    @InjectMocks
    private StatusAggregation statusAggregation;

    // For these tests, we assume that the threshold (ha.continuousprocess.threshold)
    // is set to a value that does not interfere with our branch testing.
    // (Alternatively, you might add a setter or use reflection to set continuousprocessThresholdMinutes.)
    
    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // Set up the static ApplicationContext so that the getBean call in process() works.
        HAStatusAggregationMain.context = mockContext;
        when(mockContext.getBean("statusAggregationManager")).thenReturn(statusAggregationManager);
    }

    @Test
    public void testProcess_OKStatus() {
        // --- Set up heartbeat summary that should eventually update to OK ---
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping that does NOT trigger dayCheck parsing ---
        // (For this test we let the time window be wide enough that it does not affect the logic.)
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        // Use a day name that is unlikely to match so that the "if(dayCheck)" block is skipped.
        generalMapping.setCriteria2C("NonMatchingDay");
        // Set dummy start/end times (won't be parsed if dayCheck is false)
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        // Optionally set a threshold string if needed.
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a running heartbeat ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("RUNNING");
        // Set last heartbeat time to now (so threshold is not exceeded)
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeat.setIsRunnableSw("Y");
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("Process1")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("Process1")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify that the proper interactions occurred.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assert that the heartbeat summary is updated with OK status and an appropriate description.
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
    }

    @Test
    public void testProcess_CriticalStatus() {
        // --- Set up heartbeat summary that should eventually update to CRITICAL ---
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping that does NOT trigger dayCheck parsing ---
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("NonMatchingDay");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a heartbeat that will trigger a CRITICAL status ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        // Simulate a heartbeat status that is not RUNNING.
        heartbeat.setHearbeatStatusC("STOPPED");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("Process1")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("Process1")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify that the proper interactions occurred.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assert that the heartbeat summary is updated with CRITICAL status.
        assertEquals("CRITICAL", hbSummary.getHearbeatStatusC());
        // Expect the description to contain an indication of the stopped status.
        assertTrue(hbSummary.getDescriptionC().contains("Process status is"));
    }

    @Test
    public void testProcess_DayCheckBranch() {
        // --- This test is intended to cover the branch where the mapping's dayCheck is true ---
        // Create a heartbeat summary.
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("ProcessDayCheck");
        hbSummary.setIsMultiInstanceAllowedSw("N");
        hbSummary.setAllowedMultiInstancesI(1);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("TestHost");
        heartbeatSummaryList.add(hbSummary);

        // --- Set up a mapping where the day criteria matches the current day ---
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        // Use the actual current day from DateUtil to force a match.
        String currentDay = DateUtil.getDayName();
        generalMapping.setCriteria2C(currentDay);
        // Use valid time strings that will be parsed.
        // For example, set start time to "10:00" and end time to "18:00".
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        // Optionally, set a threshold value.
        generalMapping.setCriteriaSC("600");
        generalMappings.add(generalMapping);

        // --- Set up a heartbeat that is RUNNING and within the time window ---
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("TestHost");
        heartbeat.setHearbeatStatusC("RUNNING");
        // Set last heartbeat time to now so that it does not trigger a timeout.
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeat.setIsRunnableSw("Y");
        heartbeats.add(heartbeat);

        // Stub the manager methods.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping("ProcessDayCheck")).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList("ProcessDayCheck")).thenReturn(heartbeats);

        // Execute the process method.
        statusAggregation.process();

        // Verify interactions.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("ProcessDayCheck");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("ProcessDayCheck");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Since the heartbeat is RUNNING and within the time window, we expect an OK status.
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        // And the description should include a message about the process working as configured.
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
        // Also, the mapping branch that parses the time strings should have been executed.
        // (You might add logging or further assertions if your model stores the parsed times.)
    }
}


import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.context.ApplicationContext;

import com.baml.tml.futures.managerImpl.StatusAggregationManagerImpl;
import com.baml.tml.futures.main.HAStatusAggregationMain;
import com.baml.tml.futures.model.TProcessHeartbeat;
import com.baml.tml.futures.model.TProcessHeartbeatSummary;
import com.baml.tml.futures.model.TStGeneralMapping;

public class StatusAggregationTest {

    @Mock
    private StatusAggregationManagerImpl statusAggregationManager;

    @Mock
    private ApplicationContext mockContext;

    @InjectMocks
    private StatusAggregation statusAggregation;

    @Before
    public void setUp() {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);

        // Set up the static context in HAStatusAggregationMain so that the getBean() call works.
        HAStatusAggregationMain.context = mockContext;
        when(mockContext.getBean("statusAggregationManager")).thenReturn(statusAggregationManager);
    }

    @Test
    public void testProcess() {
        // Create dummy heartbeat summary data.
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // Create dummy general mapping data.
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("Monday");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMappings.add(generalMapping);

        // Create dummy process heartbeat data.
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("RUNNING");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Stub the methods in the manager.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping(anyString())).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList(anyString())).thenReturn(heartbeats);

        // Call the process method.
        statusAggregation.process();

        // Verify that the expected manager methods were called.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assertions: Expecting the process to update the heartbeat status to OK and a positive description.
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
    }

    @Test
    public void testProcessWithCriticalStatus() {
        // Create dummy heartbeat summary data.
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        // Create dummy general mapping data.
        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("Monday");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMappings.add(generalMapping);

        // Create dummy process heartbeat data with a status that should trigger a CRITICAL result.
        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("STOPPED");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Stub the methods in the manager.
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping(anyString())).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList(anyString())).thenReturn(heartbeats);

        // Call the process method.
        statusAggregation.process();

        // Verify that the expected manager methods were called.
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assertions: Expecting the process to update the heartbeat status to CRITICAL and an appropriate description.
        assertEquals("CRITICAL", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Process status is STOPPED"));
    }
}
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.baml.tml.futures.model.TProcessHeartbeat;
import com.baml.tml.futures.model.TProcessHeartbeatSummary;
import com.baml.tml.futures.model.TStGeneralMapping;
import com.baml.tml.futures.managerImpl.StatusAggregationManagerImpl;

public class StatusAggregationTest {

    @Mock
    private StatusAggregationManagerImpl statusAggregationManager;

    @InjectMocks
    private StatusAggregation statusAggregation;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testProcess() {
        // Mock data
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("Monday");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMappings.add(generalMapping);

        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("RUNNING");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Mock behavior
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping(anyString())).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList(anyString())).thenReturn(heartbeats);

        // Call the method to test
        statusAggregation.process();

        // Verify interactions
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assertions
        assertEquals("OK", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Working as configured"));
    }

    @Test
    public void testProcessWithCriticalStatus() {
        // Mock data
        List<TProcessHeartbeatSummary> heartbeatSummaryList = new ArrayList<>();
        TProcessHeartbeatSummary hbSummary = new TProcessHeartbeatSummary();
        hbSummary.setProcessNameC("Process1");
        hbSummary.setIsMultiInstanceAllowedSw("Y");
        hbSummary.setAllowedMultiInstancesI(2);
        hbSummary.setContinuousProcessC("Y");
        hbSummary.setHostnameC("Host1");
        heartbeatSummaryList.add(hbSummary);

        List<TStGeneralMapping> generalMappings = new ArrayList<>();
        TStGeneralMapping generalMapping = new TStGeneralMapping();
        generalMapping.setCriteria2C("Monday");
        generalMapping.setCriteriaC("10:00");
        generalMapping.setCriteria4C("18:00");
        generalMappings.add(generalMapping);

        List<TProcessHeartbeat> heartbeats = new ArrayList<>();
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("Host1");
        heartbeat.setHearbeatStatusC("STOPPED");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeats.add(heartbeat);

        // Mock behavior
        when(statusAggregationManager.getHeartbeatSummary()).thenReturn(heartbeatSummaryList);
        when(statusAggregationManager.getProcessGeneralMapping(anyString())).thenReturn(generalMappings);
        when(statusAggregationManager.getProcessHearbatList(anyString())).thenReturn(heartbeats);

        // Call the method to test
        statusAggregation.process();

        // Verify interactions
        verify(statusAggregationManager, times(1)).getHeartbeatSummary();
        verify(statusAggregationManager, times(1)).getProcessGeneralMapping("Process1");
        verify(statusAggregationManager, times(1)).getProcessHearbatList("Process1");
        verify(statusAggregationManager, times(1)).updateEvaluateStataus(hbSummary);

        // Assertions
        assertEquals("CRITICAL", hbSummary.getHearbeatStatusC());
        assertTrue(hbSummary.getDescriptionC().contains("Process status is STOPPED"));
    }
}

        // Optionally, if your class uses any static context initialization, you may need to adjust that setup.
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testProcess_NoHeartbeatSummary() {
        // Setup: simulate no heartbeat summaries available.
        when(mockManager.getHeartbeatSummary()).thenReturn(Collections.emptyList());

        // Act: call the process() method.
        statusAggregation.process();

        // Verify: since there are no heartbeat summaries, update should never be called.
        verify(mockManager, never()).updateEvaluateStataus(any());
    }

    @Test
    public void testProcess_WithHeartbeatSummary() {
        // Create a dummy heartbeat summary.
        TProcessHeartbeatSummary summary = new TProcessHeartbeatSummary();
        summary.setProcessNameC("TestProcess");
        summary.setHostnameC("localhost");
        summary.setIsMultiInstanceAllowedSw("N");
        summary.setAllowedMultiInstancesI(1);
        summary.setContinuousProcessC("N");

        // Return a list with one summary.
        List<TProcessHeartbeatSummary> summaryList = Arrays.asList(summary);
        when(mockManager.getHeartbeatSummary()).thenReturn(summaryList);

        // Create a dummy general mapping.
        TStGeneralMapping mapping = new TStGeneralMapping();
        // For example, criteria2C holds the day name; here, we assume the test runs on Monday.
        mapping.setCriteria2C("Monday");
        mapping.setCriteriaC("10:00");  // Start time
        mapping.setCriteria4C("18:00"); // End time
        mapping.setCriteriaSC("600");   // Threshold in minutes
        when(mockManager.getProcessGeneralMapping(anyString())).thenReturn(Arrays.asList(mapping));

        // Create a dummy process heartbeat.
        TProcessHeartbeat heartbeat = new TProcessHeartbeat();
        heartbeat.setHostnameC("localhost");
        heartbeat.setHearbeatStatusC("RUNNING");
        heartbeat.setLastHeartbeatTimeSentIs(new Date());
        heartbeat.setIsRunnableSw("Y");
        List<TProcessHeartbeat> heartbeatList = Arrays.asList(heartbeat);
        when(mockManager.getProcessHearbatList(anyString())).thenReturn(heartbeatList);

        // Act: call the process() method.
        statusAggregation.process();

        // Verify: check that the update method was invoked on the manager.
        verify(mockManager, atLeastOnce()).updateEvaluateStataus(any(TProcessHeartbeatSummary.class));
    }
}




package com.baml.tml.futures.daoImpl;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Arrays;
import java.util.List;

import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.baml.tml.futures.model.TProcessHeartbeat;

public class TProcessHeartbeatDaoImplTest {

    @Mock
    private Session mockSession;

    @Mock
    private Transaction mockTransaction;

    @Mock
    private SQLQuery mockQuery;

    @InjectMocks
    private TProcessHeartbeatDaoImpl dao;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        when(mockSession.beginTransaction()).thenReturn(mockTransaction);
    }

    @Test
    public void testGetProcessHeartbeatList() {
        String processName = "TestProcess";

        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.addEntity(TProcessHeartbeat.class)).thenReturn(mockQuery);
        when(mockQuery.setParameter("processName", processName)).thenReturn(mockQuery);
        when(mockQuery.list()).thenReturn(Arrays.asList(new TProcessHeartbeat()));

        List<TProcessHeartbeat> result = dao.getProcessHeartbeatList(processName);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(mockTransaction).commit();
        verify(mockSession).close();
    }

    @Test
    public void testUpdateEvaluateStatus() {
        String processName = "TestProcess";
        String evaluatedStatus = "SUCCESS";

        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.setParameter("processName", processName)).thenReturn(mockQuery);
        when(mockQuery.setParameter("evaluatedStatus", evaluatedStatus)).thenReturn(mockQuery);
        when(mockQuery.executeUpdate()).thenReturn(1);

        dao.updateEvaluateStatus(processName, evaluatedStatus);

        verify(mockTransaction).commit();
        verify(mockSession).close();
    }

    @Test
    public void testGetProcessHeartbeatListByStatus() {
        String status = "ACTIVE";

        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.addEntity(TProcessHeartbeat.class)).thenReturn(mockQuery);
        when(mockQuery.setParameter("status", status)).thenReturn(mockQuery);
        when(mockQuery.list()).thenReturn(Arrays.asList(new TProcessHeartbeat()));

        List<TProcessHeartbeat> result = dao.getProcessHeartbeatListByStatus(status);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(mockTransaction).commit();
        verify(mockSession).close();
    }
}




import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import java.util.Arrays;
import java.util.List;

@RunWith(MockitoJUnitRunner.class)
public class TProcessHeartbeatDaoImplTest {

    @Mock
    private Session session;

    @Mock
    private Transaction transaction;

    @Mock
    private Query mockQuery;

    @InjectMocks
    private TProcessHeartbeatDaoImpl dao;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        when(session.beginTransaction()).thenReturn(transaction);
        when(session.createSQLQuery(anyString())).thenReturn(mockQuery);
    }

    @Test
    public void testGetDistinctProcess() {
        List<String> expectedProcesses = Arrays.asList("Process1", "Process2");
        when(mockQuery.list()).thenReturn(expectedProcesses);

        List<String> result = dao.getDistinctProcess();
        
        assertNotNull(result);
        assertEquals(2, result.size());
        assertEquals("Process1", result.get(0));
        verify(session).createSQLQuery(anyString());
    }

    @Test
    public void testGetProcessHeartbeatList() {
        List<TProcessHeartbeat> expectedList = Arrays.asList(new TProcessHeartbeat(), new TProcessHeartbeat());
        when(mockQuery.list()).thenReturn(expectedList);

        List<TProcessHeartbeat> result = dao.getProcessHeartbeatList("TestProcess");

        assertNotNull(result);
        assertEquals(2, result.size());
        verify(session).createSQLQuery(anyString());
    }

    @Test
    public void testUpdateEvaluateStatus() {
        when(mockQuery.executeUpdate()).thenReturn(1);

        dao.updateEvaluateStatus("TestProcess", "UpdatedStatus");

        verify(transaction).commit();
        verify(mockQuery).executeUpdate();
    }

    @Test
    public void testGetProcessHeartbeatListByStatus() {
        List<TProcessHeartbeat> expectedList = Arrays.asList(new TProcessHeartbeat());
        when(mockQuery.list()).thenReturn(expectedList);

        List<TProcessHeartbeat> result = dao.getProcessHeartbeatListByStatus("ACTIVE");

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(session).createSQLQuery(anyString());
    }
}


import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.jdbc.ReturningWork;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

import com.baml.tml.futures.ui.model.TProcessHeartbeatVO;

@RunWith(MockitoJUnitRunner.class)
public class TProcessHeartbeatSummaryDaoImplTest {

    @InjectMocks
    private TProcessHeartbeatSummaryDaoImpl dao;

    @Mock
    private Session session;

    @Mock
    private Transaction transaction;

    @Mock
    private Connection connection;

    @Mock
    private PreparedStatement preparedStatement;

    @Mock
    private ResultSet resultSet;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        when(session.beginTransaction()).thenReturn(transaction);
        when(session.doReturningWork(any())).thenAnswer(invocation -> {
            ReturningWork<?> work = invocation.getArgument(0);
            return work.execute(connection);
        });
    }

    @Test
    public void testGetHeartbeatVO() throws Exception {
        String processGroup = "TestGroup";

        // Mocking connection, preparedStatement, and resultSet behavior
        when(connection.prepareStatement(anyString())).thenReturn(preparedStatement);
        when(preparedStatement.executeQuery()).thenReturn(resultSet);
        when(resultSet.next()).thenReturn(true, false); // First call returns data, second returns false

        // Mocking result set data
        when(resultSet.getInt(1)).thenReturn(1);
        when(resultSet.getString(2)).thenReturn("TestProcess");
        when(resultSet.getString(3)).thenReturn("localhost");
        when(resultSet.getString(4)).thenReturn(processGroup);
        when(resultSet.getString(5)).thenReturn("OK");
        when(resultSet.getString(6)).thenReturn("Description");
        when(resultSet.getString(7)).thenReturn("GREEN");
        when(resultSet.getString(8)).thenReturn("Resolved");
        when(resultSet.getString(9)).thenReturn("Error");
        when(resultSet.getString(10)).thenReturn("User");

        // Call the method
        List<TProcessHeartbeatVO> result = dao.getHeartbeatVO(processGroup);

        // Assertions
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals("TestProcess", result.get(0).getProcessNameC());
        assertEquals("OK", result.get(0).getHearbeatStatusC());

        // Verify interactions
        verify(connection).prepareStatement(anyString());
        verify(preparedStatement).executeQuery();
        verify(resultSet, times(2)).next();
    }

    @Test
    public void testUpdateMonitorStatus() throws Exception {
        TProcessHeartbeatVO heartbeatVO = new TProcessHeartbeatVO();
        heartbeatVO.setProcessNameC("TestProcess");
        heartbeatVO.setItrsUpdate(true);
        heartbeatVO.setHearbeatStatusC("OK");
        heartbeatVO.setUpdatedByC("Admin");

        // Mock prepared statements for update queries
        when(connection.prepareStatement(anyString())).thenReturn(preparedStatement);
        when(preparedStatement.executeUpdate()).thenReturn(1);

        // Call the method
        boolean result = dao.updateMonitorStatus(heartbeatVO);

        // Assertions
        assertTrue(result);

        // Verify that updates were executed
        verify(preparedStatement, atLeastOnce()).executeUpdate();
    }

    @Test
    public void testGetHaDashboardInfo() throws Exception {
        // Mocking behavior similar to testGetHeartbeatVO
        when(connection.prepareStatement(anyString())).thenReturn(preparedStatement);
        when(preparedStatement.executeQuery()).thenReturn(resultSet);
        when(resultSet.next()).thenReturn(true, false);
        when(resultSet.getString(1)).thenReturn("TML");
        when(resultSet.getString(2)).thenReturn("Group1");
        when(resultSet.getString(3)).thenReturn("OK");
        when(resultSet.getString(4)).thenReturn("TestProcess");
        when(resultSet.getString(5)).thenReturn("GREEN");

        // Call the method
        Map<String, List<TProcessHeartbeatVO>> result = dao.getHaDashoardInfo();

        // Assertions
        assertNotNull(result);
        assertTrue(result.containsKey("TML"));
        assertEquals(1, result.get("TML").size());
        assertEquals("OK", result.get("TML").get(0).getHearbeatStatusC());

        // Verify interactions
        verify(connection).prepareStatement(anyString());
        verify(preparedStatement).executeQuery();
        verify(resultSet, times(2)).next();
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

import com.baml.tml.futures.daoImpl.TProcessHeartbeatSummaryDaoImpl;
import com.baml.tml.futures.ui.model.ApplicationStatusDTO;
import com.baml.tml.futures.ui.model.TProcessHeartbeatVO;

@RunWith(MockitoJUnitRunner.class)
public class StatusAggregationManagerImplTest {

    @InjectMocks
    private StatusAggregationManagerImpl statusAggregationManager;

    @Mock
    private TProcessHeartbeatSummaryDaoImpl heartbeatSummaryDaoImpl;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetHaDashboardInfo() {
        // Mocking heartbeat status
        TProcessHeartbeatVO tmlVO1 = new TProcessHeartbeatVO();
        tmlVO1.setHearbeatStatusC("OK");
        tmlVO1.setItrsMonitoringStatusC("GREEN");

        TProcessHeartbeatVO tmlVO2 = new TProcessHeartbeatVO();
        tmlVO2.setHearbeatStatusC("CRITICAL");
        tmlVO2.setItrsMonitoringStatusC("RED");

        TProcessHeartbeatVO consensysVO = new TProcessHeartbeatVO();
        consensysVO.setHearbeatStatusC("WARN");
        consensysVO.setItrsMonitoringStatusC("YELLOW");

        Map<String, List<TProcessHeartbeatVO>> mockData = new HashMap<>();
        mockData.put("TML", Arrays.asList(tmlVO1, tmlVO2));
        mockData.put("CONSENSYS", Arrays.asList(consensysVO));

        when(heartbeatSummaryDaoImpl.getHaDashoardInfo()).thenReturn(mockData);

        List<ApplicationStatusDTO> result = statusAggregationManager.getHaDashoardInfo();

        assertNotNull(result);
        assertEquals(2, result.size());

        ApplicationStatusDTO tmlStatus = result.get(0);
        ApplicationStatusDTO consensysStatus = result.get(1);

        assertEquals("TML", tmlStatus.getName());
        assertEquals("CRITICAL", tmlStatus.getStatus()); // Highest priority status

        assertEquals("CONSENSYS", consensysStatus.getName());
        assertEquals("WARN", consensysStatus.getStatus());

        verify(heartbeatSummaryDaoImpl, times(1)).getHaDashoardInfo();
    }

    @Test
    public void testGetHaDashboardDetails() {
        // Mocking process group data
        TProcessHeartbeatVO tmlVO1 = new TProcessHeartbeatVO();
        tmlVO1.setProcessGroupC("Group1");
        tmlVO1.setHearbeatStatusC("OK");
        tmlVO1.setItrsMonitoringStatusC("GREEN");

        TProcessHeartbeatVO tmlVO2 = new TProcessHeartbeatVO();
        tmlVO2.setProcessGroupC("Group1");
        tmlVO2.setHearbeatStatusC("CRITICAL");
        tmlVO2.setItrsMonitoringStatusC("RED");

        TProcessHeartbeatVO consensysVO = new TProcessHeartbeatVO();
        consensysVO.setProcessGroupC("Group2");
        consensysVO.setHearbeatStatusC("WARN");
        consensysVO.setItrsMonitoringStatusC("YELLOW");

        Map<String, List<TProcessHeartbeatVO>> mockData = new HashMap<>();
        mockData.put("TML", Arrays.asList(tmlVO1, tmlVO2));
        mockData.put("CONSENSYS", Arrays.asList(consensysVO));

        when(heartbeatSummaryDaoImpl.getHaDashoardInfo()).thenReturn(mockData);

        Map<String, List<ApplicationStatusDTO>> result = statusAggregationManager.getHaDashoardDetails();

        assertNotNull(result);
        assertTrue(result.containsKey("TML"));
        assertTrue(result.containsKey("CONSENSYS"));

        List<ApplicationStatusDTO> tmlStatuses = result.get("TML");
        List<ApplicationStatusDTO> consensysStatuses = result.get("CONSENSYS");

        assertEquals(1, tmlStatuses.size());
        assertEquals("Group1", tmlStatuses.get(0).getName());
        assertEquals("CRITICAL", tmlStatuses.get(0).getStatus()); // Highest priority

        assertEquals(1, consensysStatuses.size());
        assertEquals("Group2", consensysStatuses.get(0).getName());
        assertEquals("WARN", consensysStatuses.get(0).getStatus());

        verify(heartbeatSummaryDaoImpl, times(1)).getHaDashoardInfo();
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

import com.baml.tml.futures.daoImpl.TProcessHeartbeatDaoImpl;
import com.baml.tml.futures.daoImpl.TProcessHeartbeatSummaryDaoImpl;
import com.baml.tml.futures.daoImpl.TProcessStatusLogDaoImpl;
import com.baml.tml.futures.daoImpl.TStGeneralMappingDaoImpl;
import com.baml.tml.futures.model.TProcessHeartbeat;
import com.baml.tml.futures.model.TProcessHeartbeatSummary;
import com.baml.tml.futures.model.TStGeneralMapping;
import com.baml.tml.futures.ui.model.ApplicationStatusDTO;
import com.baml.tml.futures.ui.model.TProcessHeartbeatVO;

@RunWith(MockitoJUnitRunner.class)
public class StatusAggregationManagerImplTest {

    @InjectMocks
    private StatusAggregationManagerImpl statusAggregationManager;

    @Mock
    private TProcessHeartbeatDaoImpl heartbeatDaoImpl;

    @Mock
    private TStGeneralMappingDaoImpl generalMappingDaoImpl;

    @Mock
    private TProcessHeartbeatSummaryDaoImpl heartbeatSummaryDaoImpl;

    @Mock
    private TProcessStatusLogDaoImpl processStatusLogDaoImpl;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetActiveProcessList() {
        List<String> mockProcesses = Arrays.asList("Process1", "Process2");

        when(heartbeatDaoImpl.getDistinctProcess()).thenReturn(mockProcesses);

        List<String> result = statusAggregationManager.getActiveProcessList();

        assertNotNull(result);
        assertEquals(2, result.size());
        assertEquals("Process1", result.get(0));

        verify(heartbeatDaoImpl, times(1)).getDistinctProcess();
    }

    @Test
    public void testGetHeartbeatSummary() {
        List<TProcessHeartbeatSummary> mockSummaryList = Arrays.asList(new TProcessHeartbeatSummary(), new TProcessHeartbeatSummary());

        when(heartbeatSummaryDaoImpl.getProcessHeartbeatList()).thenReturn(mockSummaryList);

        List<TProcessHeartbeatSummary> result = statusAggregationManager.getHeartbeatSummary();

        assertNotNull(result);
        assertEquals(2, result.size());

        verify(heartbeatSummaryDaoImpl, times(1)).getProcessHeartbeatList();
    }

    @Test
    public void testGetProcessGeneralMapping() {
        String processName = "TestProcess";
        List<TStGeneralMapping> mockMappings = Arrays.asList(new TStGeneralMapping());

        when(generalMappingDaoImpl.getProcessGeneralMapping(processName)).thenReturn(mockMappings);

        List<TStGeneralMapping> result = statusAggregationManager.getProcessGeneralMapping(processName);

        assertNotNull(result);
        assertEquals(1, result.size());

        verify(generalMappingDaoImpl, times(1)).getProcessGeneralMapping(processName);
    }

    @Test
    public void testUpdateMonitorStatus() {
        TProcessHeartbeatVO mockHeartbeatVO = new TProcessHeartbeatVO();
        
        when(heartbeatSummaryDaoImpl.updateMonitorStatus(mockHeartbeatVO)).thenReturn(true);

        String result = statusAggregationManager.updateMonitorStatus(mockHeartbeatVO);

        assertEquals("Status updated successfully", result);

        verify(heartbeatSummaryDaoImpl, times(1)).updateMonitorStatus(mockHeartbeatVO);
    }

    @Test
    public void testGetAutosysInfo() {
        String processName = "TestProcess";
        TStGeneralMapping mockMapping = new TStGeneralMapping();
        mockMapping.setCriterialC("TestCriteria");

        when(generalMappingDaoImpl.getAutosysInfo(processName)).thenReturn(Arrays.asList(mockMapping));

        String result = statusAggregationManager.getAutosysInfo(processName);

        assertNotNull(result);
        assertTrue(result.contains("TestCriteria"));

        verify(generalMappingDaoImpl, times(1)).getAutosysInfo(processName);
    }
}






import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.Arrays;
import java.util.List;

import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class TStGeneralMappingDaoImplTest {

    @Mock
    private Session mockSession;

    @Mock
    private Transaction mockTransaction;

    @Mock
    private Query<TStGeneralMapping> mockQuery;

    @InjectMocks
    private TStGeneralMappingDaoImpl dao;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        when(mockSession.beginTransaction()).thenReturn(mockTransaction);
    }

    @Test
    public void testGetProcessGeneralMapping_Success() {
        String processName = "TestProcess";
        TStGeneralMapping mockMapping = new TStGeneralMapping();
        
        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.addEntity(TStGeneralMapping.class)).thenReturn(mockQuery);
        when(mockQuery.list()).thenReturn(Arrays.asList(mockMapping));

        List<TStGeneralMapping> result = dao.getProcessGeneralMapping(processName);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(mockTransaction).commit();
    }

    @Test
    public void testGetGUIClientMappings_Success() {
        String sourceName = "TestSource";
        TStGeneralMapping mockMapping = new TStGeneralMapping();

        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.addEntity(TStGeneralMapping.class)).thenReturn(mockQuery);
        when(mockQuery.list()).thenReturn(Arrays.asList(mockMapping));

        List<TStGeneralMapping> result = dao.getGUIClientMappings(sourceName);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(mockTransaction).commit();
    }

    @Test
    public void testGetAutosysInfo_Success() {
        String sourceName = "TestAutosys";
        TStGeneralMapping mockMapping = new TStGeneralMapping();

        when(mockSession.createSQLQuery(anyString())).thenReturn(mockQuery);
        when(mockQuery.addEntity(TStGeneralMapping.class)).thenReturn(mockQuery);
        when(mockQuery.list()).thenReturn(Arrays.asList(mockMapping));

        List<TStGeneralMapping> result = dao.getAutosysInfo(sourceName);

        assertNotNull(result);
        assertEquals(1, result.size());
        verify(mockTransaction).commit();
    }

    @Test(expected = HibernateException.class)
    public void testGetProcessGeneralMapping_Exception() {
        when(mockSession.createSQLQuery(anyString())).thenThrow(new HibernateException("DB Error"));

        dao.getProcessGeneralMapping("TestProcess");

        verify(mockTransaction).rollback();
    }
}






import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class StatusObjectTest {

    @Mock
    private BasicDaoI<Client> clientDao;

    @Mock
    private BasicDaoI<Process> processDao;

    @Mock
    private BasicDaoI<WorkUnit> workUnitDao;

    @Mock
    private BasicDaoI<Status> statusDao;

    @Mock
    private BasicDaoI<StatusType> statusTypeDao;

    @Mock
    private BasicDaoI<GenericMatches> genericMatchesDao;

    @Mock
    private BasicDaoI<GenericExceptions> genericExceptionsDao;

    @InjectMocks
    private StatusObject statusObject;

    private Client client;
    private Process process;
    private WorkUnit workUnit;
    private StatusType statusTypeSuccess;
    private StatusType statusTypeException;
    private GenericMatches genericMatches;
    private GenericExceptions genericExceptions;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        client = new Client();
        client.setName("TestClient");

        process = new Process();
        process.setName("TestProcess");

        workUnit = new WorkUnit();
        workUnit.setName("TestWorkUnit");

        statusTypeSuccess = new StatusType();
        statusTypeSuccess.setName("SUCCESS");

        statusTypeException = new StatusType();
        statusTypeException.setName("EXCEPTION");

        genericMatches = new GenericMatches();
        genericMatches.setMatchId("Match1");

        genericExceptions = new GenericExceptions();
        genericExceptions.setType("ErrorType");
    }

    @Test
    public void testSetStatusToSuccess_Success() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(Arrays.asList(statusTypeSuccess));
        when(genericMatchesDao.insert(any(GenericMatches.class))).thenReturn(1L);
        doNothing().when(statusDao).insert(any(Status.class));

        boolean result = statusObject.setStatusToSuccess(
            "TestProcess", "TestWorkUnit", "TestClient", "SomeValue", "Match1", "Match2", "Criteria", "MatchStat");

        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToSuccess_InvalidClient() throws StatusException {
        when(clientDao.readAll()).thenReturn(null);
        statusObject.setStatusToSuccess("TestProcess", "TestWorkUnit", "InvalidClient", "SomeValue", "Match1", "Match2", "Criteria", "MatchStat");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToSuccess_InvalidProcess() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(null);
        statusObject.setStatusToSuccess("InvalidProcess", "TestWorkUnit", "TestClient", "SomeValue", "Match1", "Match2", "Criteria", "MatchStat");
    }

    @Test
    public void testSetStatusToException_Success() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(Arrays.asList(statusTypeException));
        when(genericExceptionsDao.insert(any(GenericExceptions.class))).thenReturn(1L);
        doNothing().when(statusDao).insert(any(Status.class));

        boolean result = statusObject.setStatusToException(
            "TestProcess", "TestWorkUnit", "TestClient", "SomeValue", "ErrorType", "Source1", "SomeReason");

        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToException_InvalidClient() throws StatusException {
        when(clientDao.readAll()).thenReturn(null);
        statusObject.setStatusToException("TestProcess", "TestWorkUnit", "InvalidClient", "SomeValue", "ErrorType", "Source1", "SomeReason");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToException_InvalidProcess() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(null);
        statusObject.setStatusToException("InvalidProcess", "TestWorkUnit", "TestClient", "SomeValue", "ErrorType", "Source1", "SomeReason");
    }
}


 import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

import java.sql.Timestamp;

@RunWith(MockitoJUnitRunner.class)
public class StatusObjectTest {

    @InjectMocks
    private StatusObject statusObject;

    @Mock
    private BasicDaoI<GenericMatches> genericMatchesDao;
    
    @Mock
    private BasicDaoI<GenericExceptions> genericExceptionsDao;

    @Mock
    private BasicDaol<Status> statusDao;

    @Mock
    private BasicDaol<StatusType> statusTypeDao;

    @Mock
    private BasicDaol<Client> clientDao;

    @Mock
    private BasicDaol<Process> processDao;

    @Mock
    private BasicDaoI<WorkUnit> workUnitDao;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testSetStatusToSuccess() throws StatusException {
        // Mocking dependencies
        Client client = new Client();
        Process process = new Process();
        WorkUnit workUnit = new WorkUnit();
        StatusType statusType = new StatusType();
        GenericMatches gm = new GenericMatches();

        when(clientDao.readAll()).thenReturn(List.of(client));
        when(processDao.readAll()).thenReturn(List.of(process));
        when(workUnitDao.readAll()).thenReturn(List.of(workUnit));
        when(statusTypeDao.readAll()).thenReturn(List.of(statusType));
        when(genericMatchesDao.insert(any(GenericMatches.class))).thenReturn(1L);
        
        doNothing().when(statusDao).insert(any(Status.class));

        // Execute the method
        boolean result = statusObject.setStatusToSuccess("process", "workUnit", "client", "value", "matchId", "matchWithId", "matchCriteria", "matchStat");

        // Verify and assert
        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test
    public void testSetStatusToException() throws StatusException {
        // Mocking dependencies
        Client client = new Client();
        Process process = new Process();
        WorkUnit workUnit = new WorkUnit();
        StatusType statusType = new StatusType();
        GenericExceptions ge = new GenericExceptions();

        when(clientDao.readAll()).thenReturn(List.of(client));
        when(processDao.readAll()).thenReturn(List.of(process));
        when(workUnitDao.readAll()).thenReturn(List.of(workUnit));
        when(statusTypeDao.readAll()).thenReturn(List.of(statusType));
        when(genericExceptionsDao.insert(any(GenericExceptions.class))).thenReturn(1L);
        
        doNothing().when(statusDao).insert(any(Status.class));

        // Execute the method
        boolean result = statusObject.setStatusToException("process", "workUnit", "client", "value", "type", "sourceId", "reason");

        // Verify and assert
        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class StatusObjectTest {

    @Mock
    private BasicDaoI<Client> clientDao;
    
    @Mock
    private BasicDaoI<Process> processDao;
    
    @Mock
    private BasicDaoI<WorkUnit> workUnitDao;
    
    @Mock
    private BasicDaoI<Status> statusDao;
    
    @Mock
    private BasicDaoI<StatusType> statusTypeDao;
    
    @InjectMocks
    private StatusObject statusObject;

    private Client client;
    private Process process;
    private WorkUnit workUnit;
    private StatusType statusType;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        client = new Client();
        client.setName("TestClient");

        process = new Process();
        process.setName("TestProcess");

        workUnit = new WorkUnit();
        workUnit.setName("TestWorkUnit");

        statusType = new StatusType();
        statusType.setName("PROCESSING");
    }

    @Test
    public void testSetStatusToProcessing_Success() throws StatusException {
        // Mock DAO responses
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(Arrays.asList(statusType));
        
        doNothing().when(statusDao).insert(any(Status.class));

        // Call the method
        boolean result = statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");

        // Verify behavior and assert
        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidClient() throws StatusException {
        when(clientDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "InvalidClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidProcess() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("InvalidProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidWorkUnit() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "InvalidWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidStatusType() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }
}
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class StatusObjectTest {

    @Mock
    private BasicDaoI<Client> clientDao;
    
    @Mock
    private BasicDaoI<Process> processDao;
    
    @Mock
    private BasicDaoI<WorkUnit> workUnitDao;
    
    @Mock
    private BasicDaoI<Status> statusDao;
    
    @Mock
    private BasicDaoI<StatusType> statusTypeDao;
    
    @InjectMocks
    private StatusObject statusObject;

    private Client client;
    private Process process;
    private WorkUnit workUnit;
    private StatusType statusType;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        client = new Client();
        client.setName("TestClient");

        process = new Process();
        process.setName("TestProcess");

        workUnit = new WorkUnit();
        workUnit.setName("TestWorkUnit");

        statusType = new StatusType();
        statusType.setName("PROCESSING");
    }

    @Test
    public void testSetStatusToProcessing_Success() throws StatusException {
        // Mock DAO responses
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(Arrays.asList(statusType));
        
        doNothing().when(statusDao).insert(any(Status.class));

        // Call the method
        boolean result = statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");

        // Verify behavior and assert
        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidClient() throws StatusException {
        when(clientDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "InvalidClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidProcess() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("InvalidProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidWorkUnit() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "InvalidWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToProcessing_InvalidStatusType() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(null);

        statusObject.setStatusToProcessing("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }
}
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class StatusObjectTest {

    @Mock
    private BasicDaoI<Client> clientDao;
    
    @Mock
    private BasicDaoI<Process> processDao;
    
    @Mock
    private BasicDaoI<WorkUnit> workUnitDao;
    
    @Mock
    private BasicDaoI<Status> statusDao;
    
    @Mock
    private BasicDaoI<StatusType> statusTypeDao;
    
    @InjectMocks
    private StatusObject statusObject;

    private Client client;
    private Process process;
    private WorkUnit workUnit;
    private StatusType failureStatusType;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        client = new Client();
        client.setName("TestClient");

        process = new Process();
        process.setName("TestProcess");

        workUnit = new WorkUnit();
        workUnit.setName("TestWorkUnit");

        failureStatusType = new StatusType();
        failureStatusType.setName("FAILURE");
    }

    @Test
    public void testSetStatusToFailure_Success() throws StatusException {
        // Mock DAO responses
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(Arrays.asList(failureStatusType));

        // Mock statusDao.insert() for void return
        doAnswer(invocation -> null).when(statusDao).insert(any(Status.class));

        // Call the method
        boolean result = statusObject.setStatusToFailure("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");

        // Verify and assert
        assertTrue(result);
        verify(statusDao, times(1)).insert(any(Status.class));
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToFailure_InvalidClient() throws StatusException {
        when(clientDao.readAll()).thenReturn(null);

        statusObject.setStatusToFailure("TestProcess", "TestWorkUnit", "InvalidClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToFailure_InvalidProcess() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(null);

        statusObject.setStatusToFailure("InvalidProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToFailure_InvalidWorkUnit() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(null);

        statusObject.setStatusToFailure("TestProcess", "InvalidWorkUnit", "TestClient", "SomeValue");
    }

    @Test(expected = StatusException.class)
    public void testSetStatusToFailure_InvalidStatusType() throws StatusException {
        when(clientDao.readAll()).thenReturn(Arrays.asList(client));
        when(processDao.readAll()).thenReturn(Arrays.asList(process));
        when(workUnitDao.readAll()).thenReturn(Arrays.asList(workUnit));
        when(statusTypeDao.readAll()).thenReturn(null);

        statusObject.setStatusToFailure("TestProcess", "TestWorkUnit", "TestClient", "SomeValue");
    }
}
